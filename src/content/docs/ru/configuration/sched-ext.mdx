---
title: Учебник по sched-ext
description: Учебник о том, как использовать фреймворк, и разная информация
---

import { Steps } from '@astrojs/starlight/components';

Расширяемый класс планировщика, более известный как `sched-ext`, — это функция ядра Linux, которая позволяет реализовывать планировщики потоков ядра в
BPF (Berkeley Package Filter) и динамически загружать их. По сути, это позволяет конечным пользователям изменять свои планировщики в пользовательском пространстве без
необходимости собирать другое ядро только для того, чтобы иметь другой планировщик.

## Методы запуска и управления планировщиками

- **Планировщики можно найти в пакетах `scx-scheds` и `scx-scheds-git`.**
  ```sh
  # Стабильная ветка
  sudo pacman -S scx-scheds

  # Экспериментальная ветка (Эта ветка включает последние изменения
  # и может содержать планировщик, который еще не был выпущен.)
  sudo pacman -S scx-scheds-git
  ```

### Запуск планировщика в терминале

- *Чтобы запустить планировщик, откройте терминал и введите следующую команду:*
  ```sh title='Пример запуска rusty'
  sudo scx_rusty
  ```

*Это запустит планировщик rusty и отключит планировщик по умолчанию.*

Чтобы остановить планировщик, нажмите `CTRL + C`, и планировщик будет остановлен, а планировщик ядра по умолчанию снова вступит в силу.

### Служба Systemd

:::note
Эта служба будет устаревшей и заменена **[scx_loader](https://github.com/sched-ext/scx/tree/main/rust/scx_loader)**
:::

Пакет scx включает службу systemd, которая использует конфигурацию, указанную в файле `/etc/default/scx`.

В этом файле конфигурации можно указать планировщик, который запускает служба, и при необходимости включить пользовательские флаги для желаемого планировщика.

- **Если вы хотите изменить планировщик, запускаемый службой, просто измените строку `SCX_SCHEDULER=` на планировщик, который вы хотите запускать по умолчанию.**

  - ```sh title='Пример'
    SCX_SCHEDULER=scx_lavd
    ```

- **Добавление флагов**
  - Раскомментируйте `SCX_FLAGS` и добавьте нужные флаги.
    ```sh title='Пример'
    SCX_FLAGS='--performance'
    ```

*Теперь вы можете запускать/включать/останавливать планировщик, как если бы это была любая другая служба systemd.*

**Ознакомьтесь с кратким руководством по управлению им ниже.**

```sh title='Включение и запуск службы systemd'
sudo systemctl enable --now scx
```

```sh title='Запуск планировщика один раз через службу systemd'
sudo systemctl start scx
```

```sh title='Остановка планировщика SCX с помощью службы systemd'
sudo systemctl stop scx
```

*Для получения дополнительной информации об этой службе: [Служба Sched-ext systemd](<https://github.com/sched-ext/scx/blob/main/services/README.md>)*

### [scx_loader](https://github.com/sched-ext/scx/tree/main/rust/scx_loader)

*Как следует из названия, это утилита, которая функционирует как загрузчик и менеджер для фреймворка sched-ext, использующая интерфейс D-Bus.*

*Хотя она не требует systemd, ее все равно можно использовать вместе с ней.* [Ознакомьтесь с руководством по переходу для справки](/ru/configuration/sched-ext#переход-от-scxservice-к-scx_loader-подробное-руководство))

- **Имеет возможность останавливать, запускать, перезапускать, считывать информацию о планировщике scx и многое другое.**
  - *Вы можете использовать такие инструменты, как `dbus-send` или `gdbus`, для связи с ним.*
- **В этом руководстве объясняется, как использовать scx_loader с командой dbus-send.**
  - ```sh title='Запуск scx_rusty с аргументами по умолчанию'
    dbus-send --system --print-reply --dest=org.scx.Loader /org/scx/Loader org.scx.Loader.StartScheduler string:scx_rusty uint32:0
    ```
  - ```sh title='Запуск планировщика с аргументами'
    # В этом примере запускается scx_bpfland со следующими флагами: -k -c 0
    dbus-send --system --print-reply --dest=org.scx.Loader /org/scx/Loader org.scx.Loader.StartSchedulerWithArgs string:scx_bpfland array:string:"-k","-c","0"
    ```
  - ```sh title='Остановка текущего запущенного планировщика'
    dbus-send --system --print-reply --dest=org.scx.Loader /org/scx/Loader org.scx.Loader.StopScheduler
    ```
  - ```sh title='Переключение на другой планировщик в режиме 2'
    dbus-send --system --print-reply --dest=org.scx.Loader /org/scx/Loader org.scx.Loader.SwitchScheduler string:scx_lavd uint32:2
    # Это переключает на scx_lavd с режимом планировщика 2, что означает, что LAVD запускается в режиме энергосбережения
    ```
  - ```sh title='Переключение на другой планировщик с аргументами'
    dbus-send --system --print-reply --dest=org.scx.Loader /org/scx/Loader org.scx.Loader.SwitchSchedulerWithArgs string:scx_bpfland array:string:"-k","-c","0"
    ```
  - ```sh title='Получение текущего запущенного планировщика'
    dbus-send --system --print-reply --dest=org.scx.Loader /org/scx/Loader org.freedesktop.DBus.Properties.Get string:org.scx.Loader string:CurrentScheduler
    ```
  - ```sh title='Получение списка поддерживаемых планировщиков'
    dbus-send --system --print-reply --dest=org.scx.Loader /org/scx/Loader org.freedesktop.DBus.Properties.Get string:org.scx.Loader string:SupportedSchedulers
    ```
:::tip
Вот объяснение того, что означает каждый режим в scx_loader.

- **Режим 0** = `Флаги планировщика по умолчанию`
- **Режим 1** = `Игры`
- **Режим 2** = `Экономия энергии`
- **Режим 3** = `Низкая задержка`
- **Режим 4** = `Сервер` *В настоящее время доступно только для bpfland*

Пример: LAVD, работающий в режиме 1, эквивалентен `scx_lavd --performance`

*TLDR: Каждый режим — это набор различных флагов, предназначенных для улучшения предполагаемого варианта использования.*

[Для более подробного ознакомления с тем, что эти режимы меняют в каждом планировщике](https://github.com/sched-ext/scx/blob/main/rust/scx_loader/src/config.rs#L175)
:::

### Менеджер ядра CachyOS

**Доступ к планировщикам scx и их настройка можно получить с помощью нового [scx_loader](/ru/features/kernel_manager#sched-ext-framework-management).**

## Введение в основные планировщики

Поскольку существует множество планировщиков на выбор, мы хотим дать небольшое введение о имеющихся планировщиках.

:::note
Эти планировщики находятся в постоянной разработке и тестировании, поэтому ожидайте, что некоторые из их функций/флагов могут быть изменены.
:::

Не стесняйтесь сообщать о любых проблемах или отзывах на их [GitHub](/ru/configuration/sched-ext#github), указанном ниже.

### [scx_bpfland](<https://github.com/sched-ext/scx/tree/main/scheds/rust/scx_bpfland>)

**Разработано: Andrea Righi (arighi [GitHub](<https://github.com/arighi>))**

Планировщик sched_ext на основе vruntime, который отдает приоритет интерактивным рабочим нагрузкам. Очень гибкий и легко адаптируемый.

При принятии решений о том, какие ядра использовать, Bpfland учитывает их кэш-макет и то, какие ядра имеют общий кэш L2/L3, что приводит к меньшему количеству промахов кэша = большей производительности.

**Варианты использования:**

- Игры
- Использование на рабочем столе
- Мультимедиа/Аудиопроизводство
- Отличная интерактивность при интенсивных рабочих нагрузках
- Экономия энергии
- Серверные рабочие нагрузки

### [scx_flash](<https://github.com/sched-ext/scx/tree/main/scheds/rust/scx_flash>)

**Разработано: Andrea Righi (arighi [GitHub](<https://github.com/arighi>))**

Планировщик, который фокусируется на обеспечении справедливости между задачами и предсказуемости производительности. Этот планировщик представлен в качестве замены режима "lowlatency" в scx_bpfland.

**Варианты использования:**

- Игры
- Рабочие нагрузки, чувствительные к задержкам, такие как мультимедиа или обработка звука в реальном времени
- Необходимость реагировать в перегруженных ситуациях
- Стабильность производительности

### [scx_lavd](<https://github.com/sched-ext/scx/tree/main/scheds/rust/scx_lavd>)

**Разработано: Changwoo Min (multics69 [GitHub](<https://github.com/multics69>)).**

**Краткое введение в LAVD от Changwoo:**

***LAVD — это новый алгоритм планирования, который все еще находится в разработке. Он
мотивирован игровыми рабочими нагрузками, которые критичны к задержкам и
требуют интенсивного обмена данными. Он направлен на минимизацию скачков задержек при сохранении
общей хорошей пропускной способности и справедливого использования времени ЦП между задачами.***

**Варианты использования:**

- Игры
- Аудиопроизводство
- Рабочие нагрузки, чувствительные к задержкам
- Использование на рабочем столе
- Отличная интерактивность при интенсивных рабочих нагрузках
- Экономия энергии

Одной из основных и замечательных возможностей, которые включает LAVD, является **Core Compaction.** которая, не вдаваясь в технические подробности: Когда использование ЦП < 50%, в настоящее время активные ядра будут работать дольше и на более высокой частоте. Между тем, неактивные ядра будут оставаться в C-состоянии (Сон) в течение гораздо более длительного времени, что приведет к меньшему общему энергопотреблению.

### [scx_rusty](<https://github.com/sched-ext/scx/tree/main/scheds/rust/scx_rusty>)

**Разработано: David Vernet (Byte-Lab [GitHub](<https://github.com/Byte-Lab>))**

Rusty предлагает широкий спектр функций, которые расширяют его возможности, обеспечивая большую гибкость для различных вариантов использования.
Одной из этих функций является настраиваемость, позволяющая настроить Rusty в соответствии с вашими предпочтениями и конкретными требованиями.

**Варианты использования:**

- Игры
- Рабочие нагрузки, чувствительные к задержкам
- Использование на рабочем столе
- Мультимедиа/Аудиопроизводство
- Рабочие нагрузки, чувствительные к задержкам
- Отличная интерактивность при интенсивных рабочих нагрузках
- Экономия энергии

Для более подробного ознакомления с тем, что можно настроить для Rusty. Ознакомьтесь со справочной страницей

```text
scx_rusty --help
```

## Общие рекомендации

### LAVD Autopilot & Autopower

***Цитаты Changwoo Min:***
- **В режиме автопилота планировщик регулирует свой режим питания `Экономия энергии, Сбалансированный или Производительность` в зависимости от нагрузки системы, в частности от использования ЦП**

- **Autopower: Автоматически определяет режим питания планировщика на основе энергетического профиля системы, то есть EPP (Energy Performance Preference).**

:::note
LAVD теперь включает автопилот по умолчанию.
:::

```sh
# Autopower можно активировать с помощью следующего флага:
--autopower
# например:
scx_lavd --autopower
```

### Отключить ananicy-cpp

:::caution
При использовании любого из планировщиков из фреймворка sched-ext настоятельно рекомендуется отключить и избегать использования ananicy-cpp из-за возможных конфликтов, поскольку он усиливает разрыв в приоритетах, который планировщик уже создает/обрабатывает, повышая интерактивные задачи, создавая чрезмерную приоритизацию, лишая другие задачи, увеличивая вероятность срабатывания тайм-аута сторожевого таймера sched_ext, выбивая работающий планировщик, то есть вызывая зависание.
:::

**Чтобы отключить/остановить ananicy-cpp, выполните следующую команду:**

```sh
systemctl disable --now ananicy-cpp
```

## Переход от scx.service к scx_loader: Подробное руководство

:::caution
Не пытайтесь запускать scx_loader.service вместе с scx.service, иначе служба загрузчика запустится, но ничего не будет делать.

Этот конфликт возникает из-за того, что обе службы не знают друг о друге, особенно в отношении того, какая из них управляет планировщиками.
:::

:::tip
Менеджер ядра CachyOS уже включает [GUI для управления scx_loader.](/ru/features/kernel_manager#sched-ext-framework-management)
:::

**Начнем с подробного сравнения структуры файла scx.service со структурой файла конфигурации scx_loader.**

*Если у вас ранее был запущен LAVD со старым scx.service, как в примере ниже:*

```sh title='Структура файла scx.service'
# Список scx_schedulers: scx_bpfland scx_central scx_flash scx_lavd scx_layered scx_nest scx_qmap scx_rlfifo scx_rustland scx_rusty scx_simple scx_userland
SCX_SCHEDULER=scx_lavd

# Установите пользовательские флаги для планировщика
SCX_FLAGS='--performance'
```

**Тогда эквивалент в файле конфигурации scx_loader будет выглядеть так:**

```sh title='Структура файла scx_loader'
default_sched = "scx_lavd"
default_mode = "Auto"

[scheds.scx_lavd]
auto_mode = ["--performance"]
```

**[Для получения дополнительной информации о том, как настроить файл scx_loader](https://github.com/sched-ext/scx/blob/main/rust/scx_loader/configuration.md)**

  **Следуйте приведенному ниже руководству для простого перехода от `службы systemd scx` к новой утилите `scx_loader`.**
  <Steps>
  1. ```sh title='Отключение scx.service в пользу scx_loader.service'
      systemctl disable --now scx.service && systemctl enable --now scx_loader.service
      ```
  2. ```sh title='Создание файла конфигурации для scx_loader и добавление структуры по умолчанию'
     # Редактор Micro собирается создать новый файл.
     sudo micro /etc/scx_loader.toml
     # Добавьте следующие строки:

     default_sched = "scx_bpfland" # Измените эту строку на планировщик, который вы хотите, чтобы scx_loader запускал при загрузке
     default_mode = "Auto" # Возможные значения: "Auto", "Gaming", "LowLatency", "PowerSave".

     # Нажмите CTRL + S, чтобы сохранить изменения, и CTRL + Q, чтобы выйти из Micro.
     ```
  3. ```sh title='Перезапуск scx_loader'
     systemctl restart scx_loader.service
     ```
     - **Готово, scx_loader теперь загрузит и запустит желаемый планировщик.**

  </Steps>

### Отладка в scx_loader

  - ```sh title='Проверка статуса сервиса'
    systemctl status scx_loader.service
    ```
  - ```sh title='Просмотр всех записей журнала сервиса'
    journalctl -u scx_loader.service
    ```
  - ```sh title='Просмотр только журналов текущего сеанса.'
    journalctl -u scx_loader.service -b 0
    ```
- **Расширенное ведение журнала**

*Чтобы получить более подробный журнал, выполните следующие действия.*
  1) ```sh title='Редактировать файл сервиса'
     sudo systemctl edit scx_loader.service
     ```
  2) ```sh title='Добавьте следующую строку в раздел [Service]'
     Environment=RUST_LOG=trace
     ```
  3) ```sh title='Перезапустите сервис'
     sudo systemctl restart scx_loader.service
     ```
- **Снова проверьте журналы для получения более подробной информации об отладке.**

## FAQ

### Почему планировщик X работает хуже, чем другие?

- **При сравнении необходимо учитывать множество переменных. Например, как они измеряют вес задачи? Приоритизируют ли они интерактивные задачи над неинтерактивными?
  В конечном счете, это зависит от их конструктивных решений.**

### Почему все говорят, что этот планировщик X лучше всего подходит для X случая, но у меня он работает не так хорошо?

- **Как и в предыдущем ответе, выбор ЦП и его конструкция, такая как расположение ядер, то, как они совместно используют кэш между ядрами, и другие связанные факторы, могут привести к менее эффективной работе планировщика.**
- **Вот почему наличие выбора является одним из основных преимуществ фреймворка sched-ext, поэтому не бойтесь попробовать и посмотреть, какой из них лучше всего подходит для вашего случая использования. `Примеры: стабильность FPS, максимальная производительность, отзывчивость при интенсивных нагрузках и т. д.`**

### Варианты использования этих планировщиков довольно похожи... почему так?

- **В первую очередь потому, что это многоцелевые планировщики, а это означает, что они могут справляться с различными рабочими нагрузками, даже если они не преуспевают во всех областях.**

- **Чтобы определить, какой планировщик подходит вам лучше всего, нет лучшего совета, чем попробовать его самостоятельно.**

### Мне не хватает планировщика, о котором упоминают или тестируют некоторые пользователи на сервере CachyOS Discord.
**Убедитесь, что вы используете самую новую версию пакета scx-scheds под названием `scx-scheds-git`**

- **Одна из причин заключается в том, что этот планировщик очень новый и в настоящее время тестируется пользователями, поэтому он еще не добавлен в пакет `scx-scheds-git`.**

### Почему планировщик внезапно упал? Он нестабилен?

- *Этому может быть несколько причин:*
  - **Одна из самых распространенных причин заключается в том, что вы использовали ananicy-cpp вместе с планировщиком. Именно поэтому мы добавили это [предупреждение](/ru/configuration/sched-ext#disable-ananicy-cpp)**
  - **Другой причиной может быть то, что рабочая нагрузка, которую вы выполняли, превысила лимиты и возможности планировщика, что привело к его остановке.**
    - **Пример необоснованной рабочей нагрузки: `hackbench`**
  - **Или более очевидная причина: вы обнаружили ошибку в планировщике, если это так. Пожалуйста, сообщите об этом как о проблеме в их [GitHub](https://github.com/sched-ext/scx/issues) или сообщите им об этом
    в канале CachyOS Discord `sched-ext`**

### Я ранее использовал scx_loader в графическом интерфейсе Kernel Manager. Нужно ли мне все еще выполнять шаги перехода?

- **В этом конкретном случае нет, это не обязательно, потому что Kernel Manager уже обрабатывает процесс перехода.**
  - *Если вы ранее не добавляли пользовательские флаги в `/etc/default/scx` и все еще хотите их использовать.*

## Узнать больше

Если вы хотите узнать больше о фреймворке sched-ext. Посмотрите на ссылки ниже.

- [Исходный код планировщиков Sched-ext](<https://github.com/sched-ext/scx/tree/main/scheds/rust>)
- [Официальная вики-страница Sched-ext](<https://github.com/sched-ext/scx/wiki>)
- [Чангву Мин: Введение в sched-ext и планирование ЦП, часть 1](<https://blogs.igalia.com/changwoo/sched-ext-a-bpf-extensible-scheduler-class-part-1/>)
  - [Часть 2](<https://blogs.igalia.com/changwoo/sched-ext-scheduler-architecture-and-interfaces-part-2/>)
- [Андреа Риги: Повторная реализация моего планировщика Linux Rust в eBPF](<https://arighi.blogspot.com/2024/08/re-implementing-my-linux-rust-scheduler.html>)
- [Андреа Риги: Планировщики ядра Linux, сгенерированные искусственным интеллектом, на Rust](<https://arighi.blogspot.com/2024/09/ai-generated-linux-kernel-schedulers-in.html>)
